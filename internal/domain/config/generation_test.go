package config_test

import (
	"net/url"
	"path/filepath"
	"strings"
	"testing"

	"github.com/truewebber/golangci-config/internal/domain/config"
)

func TestGeneratedPath(t *testing.T) {
	t.Parallel()

	tests := []struct {
		name     string
		input    string
		want     string
		wantFunc func(string) bool
	}{
		{
			name:  "path_in_current_dir",
			input: "config.yml",
			want:  config.GeneratedFileName,
		},
		{
			name:  "path_in_subdir",
			input: "subdir/config.yml",
			want:  filepath.Join("subdir", config.GeneratedFileName),
		},
		{
			name:  "absolute_path",
			input: "/absolute/path/to/config.yml",
			want:  "/absolute/path/to/" + config.GeneratedFileName,
		},
		{
			name:  "path_with_parent_dir",
			input: "../parent/config.yml",
			want:  "../parent/" + config.GeneratedFileName,
		},
		{
			name:  "path_with_current_dir",
			input: "./current/config.yml",
			want:  filepath.Join("current", config.GeneratedFileName),
		},
		{
			name:  "path_multiple_levels",
			input: "level1/level2/level3/config.yml",
			want:  filepath.Join("level1", "level2", "level3", config.GeneratedFileName),
		},
		{
			name:  "empty_string",
			input: "",
			want:  config.GeneratedFileName,
		},
		{
			name:  "filename_without_extension",
			input: "config",
			want:  config.GeneratedFileName,
		},
		{
			name:  "path_with_spaces",
			input: "path with spaces/config.yml",
			want:  filepath.Join("path with spaces", config.GeneratedFileName),
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			t.Parallel()

			got := config.GeneratedPath(tt.input)

			if tt.wantFunc != nil {
				if !tt.wantFunc(got) {
					t.Fatalf("GeneratedPath() = %q, want to match function", got)
				}

				return
			}

			if got != tt.want {
				t.Fatalf("GeneratedPath() = %q, want %q", got, tt.want)
			}
		})
	}
}

func TestHeader(t *testing.T) {
	t.Parallel()

	tests := []struct {
		name      string
		remoteURL string
		localPath string
		want      []string
	}{
		{
			name:      "with_remote_url",
			remoteURL: "https://example.com/config.yml",
			localPath: "local.yml",
			want: []string{
				"WARNING: GENERATED FILE - DO NOT EDIT",
				"Generated by golangci-wrapper",
				"Local overrides: local.yml",
				"Remote base: https://example.com/config.yml",
			},
		},
		{
			name:      "without_remote_url",
			remoteURL: "",
			localPath: "local.yml",
			want: []string{
				"WARNING: GENERATED FILE - DO NOT EDIT",
				"Generated by golangci-wrapper",
				"Local overrides: local.yml",
				"Remote base: not configured",
			},
		},
		{
			name:      "different_local_path_formats",
			remoteURL: "https://example.com/config.yml",
			localPath: "./subdir/config.yml",
			want: []string{
				"WARNING: GENERATED FILE - DO NOT EDIT",
				"Generated by golangci-wrapper",
				"Local overrides: ./subdir/config.yml",
				"Remote base: https://example.com/config.yml",
			},
		},
		{
			name:      "url_with_params",
			remoteURL: "https://example.com/config.yml?version=1&token=abc",
			localPath: "local.yml",
			want: []string{
				"WARNING: GENERATED FILE - DO NOT EDIT",
				"Generated by golangci-wrapper",
				"Local overrides: local.yml",
				"Remote base: https://example.com/config.yml?version=1&token=abc",
			},
		},
		{
			name:      "empty_local_path",
			remoteURL: "https://example.com/config.yml",
			localPath: "",
			want: []string{
				"WARNING: GENERATED FILE - DO NOT EDIT",
				"Generated by golangci-wrapper",
				"Local overrides: ",
				"Remote base: https://example.com/config.yml",
			},
		},
		{
			name:      "very_long_local_path",
			remoteURL: "https://example.com/config.yml",
			localPath: strings.Repeat("a/", 100) + "config.yml",
			want: []string{
				"WARNING: GENERATED FILE - DO NOT EDIT",
				"Generated by golangci-wrapper",
			},
		},
		{
			name:      "special_chars_in_paths",
			remoteURL: "https://example.com/config%20file.yml",
			localPath: "path with spaces/config.yml",
			want: []string{
				"WARNING: GENERATED FILE - DO NOT EDIT",
				"Generated by golangci-wrapper",
				"Local overrides: path with spaces/config.yml",
				"Remote base: https://example.com/config%20file.yml",
			},
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			t.Parallel()

			var remoteURL *url.URL
			if tt.remoteURL != "" {
				parsed, err := url.Parse(tt.remoteURL)
				if err != nil {
					t.Fatalf("failed to parse URL: %v", err)
				}

				remoteURL = parsed
			}

			got := config.Header(remoteURL, tt.localPath)

			for _, wantLine := range tt.want {
				if !strings.Contains(got, wantLine) {
					t.Fatalf("Header() should contain %q, got:\n%s", wantLine, got)
				}
			}

			// Verify it contains warning
			if !strings.Contains(got, "WARNING") {
				t.Fatalf("Header() should contain WARNING")
			}

			// Verify it contains generated by
			if !strings.Contains(got, "Generated by golangci-wrapper") {
				t.Fatalf("Header() should contain 'Generated by golangci-wrapper'")
			}
		})
	}
}

